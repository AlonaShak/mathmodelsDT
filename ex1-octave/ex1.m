%% ==================== Базові операції ====================
clear % очищає workspace
close all % закриває всі figures
clc % очищує командний рядок
; % зупиняє виведення результатів у командному рядку
close all; clc;


%% Елементарні операції
5+6
3-2
5*8
1/2
2^6 % піднесення до степеня
1 == 2 % false - перевірка на рівність
1 ~= 2 % true - перевірка на нерівність
1 && 0 % логічне "І"
1 || 0 % логічне "АБО"
xor(1,0) % виключне "АБО" (Виключна диз'юнкція)


%% Присвоєння змінних
a = 3; % ";" зупиняє виведення результатів у командному рядку
b = 'hi';
c = 3>=1;

%% Форматоване виведення значень змінних
a = pi
disp(a)
disp(sprintf('2 decimals: %0.2f', a))
disp(sprintf('6 decimals: %0.6f', a))
format long
a
format short
a


%% Вектори і матриці
A = [1 2; 3 4; 5 6]

v = [1 2 3]
v = [1; 2; 3]
v = 1:0.1:2   % від 1 до 2, з кроком 0,1
v = 1:6       % від 1 до 6, передбачається розмір кроку 1 (вектор-рядок)

C = 2*ones(2,3) % C = [2 2 2; 2 2 2]
w = ones(1,3)   % 1x3 одиничний вектор
w = zeros(1,3) # нульовий вектор
w = rand(1,3) % рівномірний розподіл
w = randn(1,3) % нормальний розподіл (mean=0, var=1)
w = -6 + sqrt(10)*(randn(1,10000));  % (mean = -6, var = 10)
hist(w)    % побудова гістограми з 10-ти стовпчиків (10 - за замовчуванням)
hist(w,50) % побудова гістограми з 50-ти стовпчиків


E = eye(4)   % 4x4 оголошення одиничної матриці

%% Функція help
help eye
help rand
help help

%% ==================== Переміщення даних ====================
%% виміри
sz = size(A) % матриця 1x2: [(кількість рядків) (кількість стовпців)]
size(A,1) % кількість рядків
size(A,2) % кількість стовпців
length(v) % кількість більшого з вимірів

%% завантаження даних
pwd   % показати поточну директорію (поточний шлях)
cd 'D:\GitHub\mathmodelsDT\ex0-octave'  % змінити директорію
ls    % список файлів в поточній директорії
load temp.dat   % завантаження даних з файлу temp.dat
load('temp.dat')
who   % список змінних у workspace
whos  % список змінних у workspace (детальний перегляд)
clear temp      % видалення змінної temp з workspace
v = temp(1:10); % перші 10 елементів
save hello.mat v;  % збереження змінної temp у файл hello.mat
save hello.txt v -ascii; % збереження у ascii форматі
% fopen, fread, fprintf, fscanf також працюють, але не будуть використовуватися

%% Індекси матриць
A(3,2)  % індекси вказують на позицію елеманта/елементів (номер рядка,номер стовпця)
A(2,:)  % отримання 2-го рядка
        % ":" означає кожен елемент цього виміру
A(:,2)  % отримання 2-го стовпця
A([1 3],:) % всі елементи 1-го та 3-го рядків

A(:,2) = [10; 11; 12]     % змінити значення 2-го стовпця
A = [A, [100; 101; 102]]; % добавити вектор як стовпець
A(:) % представлення всіх елементів матриці у вигляді вектора

% Об’єднання даних
A = [1 2; 3 4; 5 6]
B = [11 12; 13 14; 15 16] % однакова розмірність
C = [A B]  % об’єднання матриць A і B зліва направо
C = [A, B] % об’єднання матриць A і B зліва направо
C = [A; B] % об’єднання матриць A і B зверху вних

%% ==================== Обчислення ====================

%% ініціалізація змінних
A = [1 2;3 4;5 6];
B = [11 12;13 14;15 16];
C = [1 1;2 2];
v = [1;2;3];

%% Дії над матрицями
A * C  % множення матриць
A .* B % поелементне множення
% A .* C  чи A * B дає помилку - несумісні розмірності
A .^ 2 % поелементне піднесення до квадрата
1./v
log(v)  % такі функції розраховують значення поелементно для векторів і матриць
exp(v)
abs(v)
-v  % -1*v
v + ones(length(v), 1) % v + 1
A'  % транспонування матриці

%% корисні функції
% max  (або min)
a = [1 15 2 0.5]
val = max(a)
[val,ind] = max(a) % val -  максимальний елемент вектора a; ind - індекс максимального елемента
val = max(A) % якщо A це матриця, то функція max() повертає максимальний елемент кожного стовпця

% пошук індексів елементів за умовою
find(a < 3) % пошук індексів елементів вектора, значення яких менші 3
A = magic(3) % генерація квадратної матриці, в якій сума елементів рядкі=сумі елементів стовпців=сумі елементів діагоналі
[r,c] = find(A>=7)  % індекси рядків та стовпців, що вказують на елементи, які задовільняють умову

% сума, добуток
sum(a) % сума елементів вектора
% якщо a це матриця, то функція sum(a) повертає суму елементів кожного стовпця
prod(a)
floor(a) % округлення до меншого
ceil(a) % округлення до більшого
max(rand(3),rand(3))
max(A,[],1) % максимум серед елементів стовпця(за замовчуванням для стовпців - max(A,[]))
max(A,[],2)  % максимум серед елементів рядка
A = magic(9)
sum(A,1) % сума елементів кожного стовпця
sum(A,2) % сума елементів кожного рядка
sum(sum( A .* eye(9) )) % сума діагональних елементів
sum(sum( A .* flipud(eye(9)) )) % сума елементів побічної діагоналі

inv(A) % A*inv(A)=E обернена матриця
pinv(A) % inv(A'*A)*A' псевдообернена матриця Мура-Пенроуза

%% ==================== Відображення даних ====================

%% Побудова графіків
t = [0:0.01:0.98];
y1 = sin(2*pi*4*t);
plot(t,y1); % побудова графіка
y2 = cos(2*pi*4*t);
hold on;  % "hold on" затримання попереднього графіку
% "hold off" вимкнути затримання
plot(t,y2,'r'); % побудова графіка, означення кольору кривої
xlabel('time'); % означення осі Х
ylabel('value'); % означення осі Y
legend('sin','cos');
title('my plot');
print -dpng 'myPlot.png'
close;           % закриття всіх фігур
close all;
figure(1); plot(t, y1);
figure(2); plot(t, y2);
figure(2), clf;  % очищення фігури
subplot(1,2,1);  % Розділення вікна відображення даних сіткою 1x2, доступ до 1-го графіка
plot(t,y1);
subplot(1,2,2);  % Розділення вікна відображення даних сіткою 1x2, доступ до 2-го графіка
plot(t,y2);
axis([0.5 1 -1 1]);  % зміна масштабу осей

%% відобразити матрицю (або зображення)
figure;
imagesc(magic(15)), colorbar, colormap gray;

%% ==================== Оператори for, while, if ====================

v = zeros(10,1);
for i=1:10,
    v(i) = 2^i;
end;

i = 1;
while i <= 5,
  v(i) = 100;
  i = i+1;
end

i = 1;
while true,
  v(i) = 999;
  i = i+1;
  if i == 6,
    break;
  end;
end

if v(1)==1,
  disp('The value is one!');
elseif v(1)==2,
  disp('The value is two!');
else
  disp('The value is not one or two!');
end

